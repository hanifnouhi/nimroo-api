import {
  BadRequestException,
  ConflictException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { UserRepository } from './user.repository';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dtos/create-user.dto';
import * as bcrypt from 'bcrypt';
import { UpdateUserDto } from './dtos/update-user.dto';
import { UserErrorDto } from './dtos/user-error.dto';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { FilterQuery } from 'mongoose';
import { UserProvider, UserStatus } from './user.enums';
import { UpdateRefreshTokenDto } from '../auth/dtos/update-refresh-token.dto';
import { ChangePasswordDto } from '../auth/dtos/change-password.dto';
import { UserDto } from './dtos/user.dto';
import { ServiceUsageDto, UserUsageDto } from './dtos/usage-response.dto';
import { PLANS_CONFIG } from '../common/membership/membership.config';

/**
 * Service responsible of user CRUD and other operations
 */
@Injectable()
export class UserService {
  constructor(
    private userRepository: UserRepository,
    @InjectPinoLogger(UserService.name) private readonly logger: PinoLogger,
  ) {}

  /**
   * Find user by email (email used as username) and password included in result
   *
   * @param {string} email - user email
   * @returns {Promise<UserDocument | null>} A promise resolving to user document or null
   */
  async findByEmail(email: string): Promise<UserDocument | null> {
    this.logger.debug(`Attempting to find a user with ${email} email`);
    try {
      const user = await this.userRepository.findOneWithPassword({ email });
      this.logger.info(`user with ${email} email found successfully`);
      return user;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in finding user with email.',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Find user by id
   *
   * @param {string} userId - user id generated by mongo db
   * @returns {Promise<UserDocument | null>} A promise resolving to user document or null
   */
  async findById(userId: string): Promise<UserDocument | null> {
    this.logger.debug(`Attempting to find a user with ${userId} id`);
    try {
      const user = await this.userRepository.findOne({ _id: userId });
      this.logger.info(`user with ${userId} id found successfully`);
      return user;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in finding user with id.',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Create user
   *
   * @param {CreateUserDto} data - user create dto containing email, password and name (optional)
   * @returns {Promise<UserDocument>} A promise resolving to user created document or null
   */
  async create(data: CreateUserDto): Promise<UserDocument> {
    this.logger.debug(`Attempting to create a user with ${data.email} email`);
    try {
      const user = await this.userRepository.create(data);
      this.logger.info(`User created successfully with email ${data.email}`);
      return user;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in creating user.',
      );
      if (error.code === 11000) {
        const userError = new UserErrorDto(
          'Email is registered before',
          error.code,
          error.message,
        );
        throw new ConflictException(userError);
      }
      throw new InternalServerErrorException();
    }
  }

  /**
   * Update user
   *
   * @param {string} userId - user id
   * @param {UserDto} data - partial of user dto
   * @returns {Promise<UserDocument>} A promise resolving to user updated document or null
   */
  async update(
    userId: string,
    data: Partial<UserDto>,
  ): Promise<UserDocument | null> {
    this.logger.debug(`Attempting to update the user data with id: ${userId}`);
    try {
      const user = await this.userRepository.findOneAndUpdate(
        { _id: userId },
        data,
      );
      this.logger.info(`User updated successfully with id: ${userId}`);
      return user;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in updating user.',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Find all users in db
   *
   * @returns {Promise<UserDocument[] | null> } A promise resolving to the array of user documents or null
   */
  async findAll(
    filter: FilterQuery<UserDocument>,
    options: Record<string, any>,
  ): Promise<UserDocument[] | null> {
    this.logger.debug(`Attempting to find all users`);
    try {
      const users = await this.userRepository.find(filter, options);
      this.logger.info(`Find all users done successfully`);
      return users.data;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in finding all users',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Delete user by id, set status to deleted
   *
   * @param {string} userId - user id
   * @returns {Promise<UserDocument | null>} A promise resolving to user deleted document or null
   */
  async delete(userId: string): Promise<UserDocument | null> {
    this.logger.debug(`Attempting to delete user with id: ${userId}`);
    try {
      const user = await this.userRepository.findOneAndUpdate(
        { _id: userId },
        { status: UserStatus.Deleted },
      );
      this.logger.info(`User deleted successfully with id: ${userId}`);
      return user;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in deleting user.',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Update refresh token by user id
   *
   * @param {string} userId - user id
   * @param {UpdateRefreshTokenDto} dto - update refresh token dto containing refresh token
   * @returns {Promise<void>} A promise resolving to void
   */
  async updateRefreshToken(
    userId: string,
    dto: UpdateRefreshTokenDto,
  ): Promise<void> {
    this.logger.debug(`Attempting to update refresh token with id: ${userId}`);
    try {
      await this.userRepository.findOneAndUpdate(
        { _id: userId },
        { refreshToken: dto.refreshToken },
      );
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in updating refresh token',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Update user password by user id
   *
   * @param {string} userId - user id
   * @param {ChangePasswordDto} dto - change password dto containing new password
   * @returns {Promise<UserDocument | null>} A promise resolving to User Document or null
   */
  async updatePassword(
    userId: string,
    dto: ChangePasswordDto,
  ): Promise<boolean> {
    this.logger.debug(
      `Attempting to update the user password with id: ${userId}`,
    );
    try {
      const user = await this.userRepository.findOneAndUpdate(
        { _id: userId },
        dto,
      );
      this.logger.info(`User password updated successfully with id: ${userId}`);
      if (user) {
        return true;
      }
      return false;
    } catch (error) {
      this.logger.error(
        { error: error.message, stack: error.stack },
        'Error in updating user password.',
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Update verificationEmailSentAt for user by user id
   *
   * @param {string} userId - user id
   * @returns {Promise<void>} A promise resolving to void or throw an error if not
   */
  async updateVerificationEmailSentAt(userId: string): Promise<void> {
    this.logger.debug(
      `Attempting to update verificationEmailSentAt for user with id: ${userId}`,
    );
    try {
      await this.userRepository.findOneAndUpdate(
        { _id: userId },
        { verificationEmailSentAt: new Date() },
      );
      this.logger.info(
        `verificationEmailSentAt updated successfully for user with id: ${userId}`,
      );
    } catch (error) {
      this.logger.error(
        { error },
        `Error in updating verificationEmailSentAt for user with id: ${userId}.`,
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Update passwordResetEmailSentAt for user by user id
   *
   * @param {string} userId - user id
   * @returns {Promise<void>} A promise resolving to void or throw an error if not
   */
  async updatePasswordResetEmailSentAt(userId: string): Promise<void> {
    this.logger.debug(
      `Attempting to update passwordResetEmailSentAt for user with id: ${userId}`,
    );
    try {
      await this.userRepository.findOneAndUpdate(
        { _id: userId },
        { passwordResetEmailSentAt: new Date() },
      );
      this.logger.info(
        `passwordResetEmailSentAt updated successfully for user with id: ${userId}`,
      );
    } catch (error) {
      this.logger.error(
        { error },
        `Error in updating passwordResetEmailSentAt for user with id: ${userId}.`,
      );
      throw new InternalServerErrorException();
    }
  }

  /**
   * Unlink a social provider from a user account
   *
   * @param {string} userId - The ID of the user
   * @param {string} targetProvider - The provider to unlink (e.g., 'google')
   */
  async unlinkProvider(
    userId: string,
    targetProvider: UserProvider,
  ): Promise<UserDocument | null> {
    this.logger.debug(
      `Attempting to unlink provider ${targetProvider} from user id: ${userId}`,
    );
    const user = await this.userRepository.findOneWithPassword({ _id: userId });
    if (!user) {
      throw new NotFoundException('User not found');
    }
    let { password, oauthProviders, provider: userProvider, providerId } = user;
    if (!oauthProviders || !oauthProviders[targetProvider]) {
      throw new BadRequestException(`Provider ${targetProvider} not linked`);
    }

    // Prevent unlinking last login method
    if (
      !password &&
      Object.keys(oauthProviders).length === 1 &&
      Object.keys(oauthProviders).indexOf(targetProvider) !== -1
    ) {
      throw new BadRequestException(
        'Cannot unlink the last login method. Add another provider or password first.',
      );
    }

    // If the last provider is the target provider, clear providerId and set provider to local
    if (providerId === oauthProviders[targetProvider].id) {
      providerId = '';
      userProvider = UserProvider.Local;
    }

    // Clear target provider from oauth providers
    delete oauthProviders[targetProvider];

    try {
      const updatedUser = await this.userRepository.findOneAndUpdate(
        { _id: userId },
        {
          provider: userProvider,
          providerId,
          oauthProviders,
        },
      );
      this.logger.info(
        `Provider ${targetProvider} unlinked successfully from user ${userId}`,
      );
      return updatedUser;
    } catch (error) {
      this.logger.error(
        { error },
        `Error unlinking provider ${targetProvider} for user ${userId}`,
      );
      throw new InternalServerErrorException('Failed to unlink provider');
    }
  }

  /**
   * Increment limit usage for each service
   *
   * @param {string} userId - Id of the user
   * @param {string} serviceName - Service name
   */
  async incrementUsage(userId: string, serviceName: string): Promise<void> {
    this.logger.debug(
      `Attempting to increment usage for user id: ${userId} and service: ${serviceName}`,
    );
    // Find user by id
    const user = await this.userRepository.findOne({ _id: userId });
    if (!user) {
      this.logger.warn(`User with id: ${userId} not found`);
      throw new NotFoundException('User not found');
    }

    // Get now date
    const now = new Date();
    // Get last used date
    const lastReset = new Date(user.lastResetDate);

    // Check if the current request is on a different calendar day than the last reset
    const isNewDay =
      now.getFullYear() !== lastReset.getFullYear() ||
      now.getMonth() !== lastReset.getMonth() ||
      now.getDate() !== lastReset.getDate();

    // If it's a new day, clear dailyUsage and set lastResetDate to now
    if (isNewDay) {
      user.dailyUsage = new Map();
      user.lastResetDate = now;
    }

    // Get usage count
    const currentCount = user.dailyUsage.get(serviceName) || 0;
    user.dailyUsage.set(serviceName, currentCount + 1);

    // Update user data in db
    this.logger.debug(
      `Find and update user data in db with user id: ${userId}`,
    );
    await this.userRepository.findOneAndUpdate({ _id: userId }, user);
  }

  /**
   * Get usage count of a service
   *
   * @param {string} userId - The user id
   * @param {string} serviceName - Service name
   * @returns {Promise<number>} A promise resolving to number that shows the usage
   */
  async getUsageCount(userId: string, serviceName: string): Promise<number> {
    this.logger.debug(
      `Attempting to get usage count for user id: ${userId} for service: ${serviceName}`,
    );
    const user = await this.userRepository.findOne({ _id: userId });
    if (!user) return 0;

    const now = new Date();
    // Check if it's a new day (Reset Logic)
    if (user.lastResetDate.toDateString() !== now.toDateString()) {
      return 0;
    }

    return user.dailyUsage.get(serviceName) || 0;
  }
}
