import { ConflictException, Injectable, InternalServerErrorException } from '@nestjs/common';
import { UserRepository } from './user.repository';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dtos/create-user.dto';
import * as bcrypt from 'bcrypt';
import { UpdateUserDto } from './dtos/update-user.dto';
import { UserErrorDto } from './dtos/user-error.dto';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';

/**
 * Service responsible of user CRUD and other operations
 */
@Injectable()
export class UserService {

    constructor(
        private userRepository: UserRepository,
        @InjectPinoLogger(UserService.name) private readonly logger: PinoLogger
    ) {}

    /**
     * Find user by email (email used as username) and password included in result
     * 
     * @param {string} email - user email 
     * @returns {Promise<UserDocument | null>} A promise resolving to user document or null
     */
    async findByEmail(email: string): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to find a user with ${email} email`);
        try {
            const user = this.userRepository.findOneWithPassword({ email });
            this.logger.info(`user with ${email} email found successfully`);
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in finding user with email.');
            if (error.code === 11000) {
                const userError = new UserErrorDto(
                    'Email is registered before',
                    error.code,
                    error.message
                )
                throw new ConflictException(userError);
            }

            throw new InternalServerErrorException();
        }
    }

    /**
     * Find user by id
     * 
     * @param {string} userId - user id generated by mongo db
     * @returns {Promise<UserDocument | null>} A promise resolving to user document or null
     */
    async findById(userId: string): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to find a user with ${userId} id`);
        try {
            const user = this.userRepository.findOne({ _id: userId });
            this.logger.info(`user with ${userId} id found successfully`);
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in finding user with id.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Create user
     * 
     * @param {CreateUserDto} data - user create dto containing email, password and name (optional) 
     * @returns {Promise<UserDocument>} A promise resolving to user created document or null
     */
    async create(data: CreateUserDto): Promise<UserDocument> {
        this.logger.debug(`Attempting to create a user with ${data.email} email`);
        try {
            data.password = await this.hashPassword(data.password);
            const user = this.userRepository.create(data);
            this.logger.info(`User created successfully with email ${data.email}`)
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in creating user.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Update user
     * 
     * @param {string} userId - user id
     * @param {UpdateUserDto} data - update user dto 
     * @returns {Promise<UserDocument>} A promise resolving to user updated document or null
     */
    async update(userId: string, data: UpdateUserDto): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to update the user data with id: ${userId}`)
        try {
            const user = this.userRepository.findOneAndUpdate({ _id: userId }, data);
            this.logger.info(`User updated successfully with id: ${userId}`)
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in updating user.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Find all users in db
     * 
     * @returns {Promise<UserDocument[] | null> } A promise resolving to the array of user documents or null
     */
    async findAll(): Promise<UserDocument[] | null> {
        this.logger.debug(`Attempting to find all users`)
        try {
            const users = this.userRepository.find({});
            this.logger.info(`Find all users done successfully`)
            return users;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in finding all users');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Hash password when creating a user to prevent save password in db as a plain text
     * 
     * @param {string} password - Plain text password to hash
     * @returns {Promise<string>} A promise resolving to the hashed password
     */
    async hashPassword(password: string): Promise<string> {
        this.logger.debug('Attempting to hash user password');
        return await bcrypt.hash(password, 10);
    }
}
