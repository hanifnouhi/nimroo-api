import { ConflictException, Injectable, InternalServerErrorException } from '@nestjs/common';
import { UserRepository } from './user.repository';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dtos/create-user.dto';
import * as bcrypt from 'bcrypt';
import { UpdateUserDto } from './dtos/update-user.dto';
import { UserErrorDto } from './dtos/user-error.dto';
import { InjectPinoLogger, PinoLogger } from 'nestjs-pino';
import { FilterQuery } from 'mongoose';
import { UserStatus } from './user.enums';
import { UpdateRefreshTokenDto } from '../auth/dtos/update-refresh-token.dto';
import { ChangePasswordDto } from '../auth/dtos/change-password.dto';

/**
 * Service responsible of user CRUD and other operations
 */
@Injectable()
export class UserService {

    constructor(
        private userRepository: UserRepository,
        @InjectPinoLogger(UserService.name) private readonly logger: PinoLogger
    ) {}

    /**
     * Find user by email (email used as username) and password included in result
     * 
     * @param {string} email - user email 
     * @returns {Promise<UserDocument | null>} A promise resolving to user document or null
     */
    async findByEmail(email: string): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to find a user with ${email} email`);
        try {
            const user = await this.userRepository.findOneWithPassword({ email });
            this.logger.info(`user with ${email} email found successfully`);
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in finding user with email.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Find user by id
     * 
     * @param {string} userId - user id generated by mongo db
     * @returns {Promise<UserDocument | null>} A promise resolving to user document or null
     */
    async findById(userId: string): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to find a user with ${userId} id`);
        try {
            const user = await this.userRepository.findOne({ _id: userId });
            this.logger.info(`user with ${userId} id found successfully`);
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in finding user with id.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Create user
     * 
     * @param {CreateUserDto} data - user create dto containing email, password and name (optional) 
     * @returns {Promise<UserDocument>} A promise resolving to user created document or null
     */
    async create(data: CreateUserDto): Promise<UserDocument> {
        this.logger.debug(`Attempting to create a user with ${data.email} email`);
        try {
            data.password = await this.hashPassword(data.password);
            const user = await this.userRepository.create(data);
            this.logger.info(`User created successfully with email ${data.email}`)
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in creating user.');
            if (error.code === 11000) {
                const userError = new UserErrorDto(
                    'Email is registered before',
                    error.code,
                    error.message
                )
                throw new ConflictException(userError);
            }
            throw new InternalServerErrorException();
        }
    }

    /**
     * Update user
     * 
     * @param {string} userId - user id
     * @param {UpdateUserDto} data - update user dto 
     * @returns {Promise<UserDocument>} A promise resolving to user updated document or null
     */
    async update(userId: string, data: UpdateUserDto): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to update the user data with id: ${userId}`)
        try {
            const user = await this.userRepository.findOneAndUpdate({ _id: userId }, data);
            this.logger.info(`User updated successfully with id: ${userId}`)
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in updating user.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Find all users in db
     * 
     * @returns {Promise<UserDocument[] | null> } A promise resolving to the array of user documents or null
     */
    async findAll(filter: FilterQuery<UserDocument>, options: Record<string, any>): Promise<UserDocument[] | null> {
        this.logger.debug(`Attempting to find all users`)
        try {
            const users = await this.userRepository.find(filter, options);
            this.logger.info(`Find all users done successfully`)
            return users.data;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in finding all users');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Delete user by id, set status to deleted
     * 
     * @param {string} userId - user id
     * @returns {Promise<UserDocument | null>} A promise resolving to user deleted document or null
     */
    async delete(userId: string): Promise<UserDocument | null> {
        this.logger.debug(`Attempting to delete user with id: ${userId}`);
        try {
            const user = await this.userRepository.findOneAndUpdate({ _id: userId }, { status: UserStatus.Deleted });
            this.logger.info(`User deleted successfully with id: ${userId}`);
            return user;
        } catch(error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in deleting user.');
            throw new InternalServerErrorException();
        }
    }

    /**
     * Update refresh token by user id
     * 
     * @param {string} userId - user id
     * @param {UpdateRefreshTokenDto} dto - update refresh token dto containing refresh token
     * @returns {Promise<void>} A promise resolving to void
     */
    async updateRefreshToken(userId: string, dto: UpdateRefreshTokenDto): Promise<void> {
        this.logger.debug(`Attempting to update refresh token with id: ${ userId }`);
        try {
            await this.userRepository.findOneAndUpdate(
                { _id: userId},
                { refreshToken: dto.refreshToken }
            );
        } catch (error) {
            this.logger.error({ error: error.message, stack: error.stack }, 'Error in updating refresh token');
            throw new InternalServerErrorException();
        }
        
    }

    /**
     * Change user password by user id
     * 
     * @param {string} userId - user id
     * @param {ChangePasswordDto} dto - change password dto containing new password
     * @returns {Promise<void>} A promise resolving to void
     */
    async changePassword(userId: string, dto: ChangePasswordDto): Promise<void> {
        const hashed = await this.hashPassword(dto.password);
        await this.userRepository.findOneAndUpdate(
            { _id: userId },
            { password: hashed}
        );
    }

    /**
     * Hash password when creating a user to prevent save password in db as a plain text
     * 
     * @param {string} password - Plain text password to hash
     * @returns {Promise<string>} A promise resolving to the hashed password
     */
    async hashPassword(password: string): Promise<string> {
        this.logger.debug('Attempting to hash user password');
        return await bcrypt.hash(password, 10);
    }
}
